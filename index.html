<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ•°å­—ç©å…·å¤§ä¿å« - ç­–ç•¥æŒ‘æˆ˜ç‰ˆ (æ”¾ç½®é™åˆ¶ & éš¾åº¦å‡çº§)</title>
    <style>
        /* (æ ·å¼éƒ¨åˆ†åŸºæœ¬ä¸å˜ï¼Œå¾®è°ƒäº†ä»»åŠ¡æ å®½åº¦é€‚åº”æ–°æ–‡å­—) */
        body {
            font-family: 'Comic Sans MS', 'Arial Rounded MT Bold', sans-serif;
            background-color: #f0f8ff;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px; 
            user-select: none;
        }

        h1 { color: #ff6b6b; margin-bottom: 5px; }
        #game-info { font-size: 20px; margin-bottom: 5px; color: #333; }
        .heart { color: red; }

        /* æ³¢æ¬¡ä»»åŠ¡è¿›åº¦æ ·å¼ */
        #wave-quest-progress {
            font-size: 16px; /* ç¨å¾®è°ƒå°å­—ä½“ä»¥æ”¾ä¸‹æ›´å¤šå†…å®¹ */
            margin-bottom: 10px;
            padding: 5px 15px;
            background-color: #fff3cd;
            border: 2px solid #ffecb5;
            border-radius: 10px;
            color: #856404;
            display: flex;
            gap: 10px;
        }
        .quest-group { display: flex; flex-direction: column; align-items: center; background: rgba(255,255,255,0.5); padding: 2px 5px; border-radius: 5px;}
        .quest-item { margin: 0 2px; font-size: 14px;}
        .status-done { color: green; font-weight: bold; }
        .status-todo { color: red; }
        .status-placed { color: blue; font-weight: bold; } /* ã€æ–°å¢ã€‘å·²æ”¾ç½®çŠ¶æ€é¢œè‰² */

        #game-container {
            position: relative;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            border-radius: 15px;
            overflow: hidden;
            background-color: #a3d9a5; 
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        #ui-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: space-around;
            box-sizing: border-box;
        }

        .btn {
            padding: 10px 20px; 
            font-size: 18px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px #999;
            transition: all 0.1s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .btn span.icon-placeholder { display: inline-block; width: 25px; text-align: center;}
        .btn:active { transform: translateY(4px); box-shadow: 0 1px #999; }

        #btn-tier1 { background-color: #4CAF50; color: white; }
        #btn-tier2 { background-color: #2196F3; color: white; }
        #btn-tier3 { background-color: #F44336; color: white; }
        #btn-start { background-color: #FFC107; color: black; font-size: 20px;}

        #math-modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            justify-content: center;
            align-items: center;
        }

        #modal-content {
            background-color: #fffbe0;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            border: 5px solid #ffb74d;
            box-shadow: 0 0 30px rgba(255, 183, 77, 0.8);
        }

        #question-text { font-size: 40px; margin-bottom: 30px; color: #333; }
        #question-visual { font-size: 50px; margin-bottom: 20px; }

        .answer-btn {
            margin: 10px;
            padding: 15px 30px;
            font-size: 35px;
            background-color: #ffeb3b;
            border: 3px solid #fbc02d;
            border-radius: 15px;
            cursor: pointer;
        }
        .answer-btn:hover { background-color: #fff176; }

        #instruction { color: #666; margin-bottom: 5px; font-weight: bold; font-size: 14px;}
        .highlight-text { color: #ff6b6b; }
        
        #loading-screen {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: #a3d9a5; color: white; font-size: 30px;
            display: flex; justify-content: center; align-items: center;
            z-index: 50;
            flex-direction: column;
        }
        #loading-tips { font-size: 16px; margin-top: 20px; color: #eee; }

    </style>
</head>
<body>

    <h1>æ•°å­—ç©å…·å¤§ä¿å«</h1>
    <div id="instruction">è§„åˆ™å‡çº§ï¼š<span class="highlight-text">æ¯ä¸€æ³¢æ”»å‡»ï¼Œæ¯ç§ç±»å‹çš„ç©å…·åªèƒ½æ”¾ç½®ä¸€æ¬¡ï¼</span>(ä¸”éœ€å…ˆå®Œæˆç­”é¢˜ä»»åŠ¡)</div>
    <div id="game-info">
        çˆ±å¿ƒ: <span id="lives-display">â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸</span> | æ³¢æ¬¡: <span id="wave-display">1</span>
    </div>

    <div id="wave-quest-progress">
        <div>æœ¬æ³¢çŠ¶æ€:</div>
        <div class="quest-group">ç®€å• <span class="quest-item">ä»»åŠ¡[<span id="q1-quest" class="status-todo">âœ—</span>]</span><span class="quest-item">å·²æ”¾[<span id="q1-placed" class="status-todo">âœ—</span>]</span></div>
        <div class="quest-group">ä¸­ç­‰ <span class="quest-item">ä»»åŠ¡[<span id="q2-quest" class="status-todo">âœ—</span>]</span><span class="quest-item">å·²æ”¾[<span id="q2-placed" class="status-todo">âœ—</span>]</span></div>
        <div class="quest-group">å›°éš¾ <span class="quest-item">ä»»åŠ¡[<span id="q3-quest" class="status-todo">âœ—</span>]</span><span class="quest-item">å·²æ”¾[<span id="q3-placed" class="status-todo">âœ—</span>]</span></div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="loading-screen">
            <div>æ­£åœ¨åŠ è½½æ¸¸æˆç´ æ...</div>
            <div id="loading-tips">å¦‚æœå›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œå°†ä½¿ç”¨æ›¿ä»£å›¾å½¢ï¼Œæ¸¸æˆä»å¯è¿›è¡Œã€‚</div>
        </div>
        
        <div id="ui-overlay">
            <button id="btn-tier1" class="btn" onclick="askQuestion(1)"><span class="icon-placeholder">ğŸ»</span> ç®€å•</button>
            <button id="btn-tier2" class="btn" onclick="askQuestion(2)"><span class="icon-placeholder">ğŸ¦†</span> ä¸­ç­‰</button>
            <button id="btn-tier3" class="btn" onclick="askQuestion(3)"><span class="icon-placeholder">â„ï¸</span> å›°éš¾</button>
            <div style="flex-grow: 1;"></div>
            <button id="btn-start" class="btn" onclick="startNextWave()">â–¶ å¼€å§‹ä¸‹ä¸€æ³¢è¿›æ”»</button>
        </div>
    </div>

    <div id="math-modal">
        <div id="modal-content">
            <div id="question-visual"></div>
            <div id="question-text">é¢˜ç›®åŠ è½½ä¸­...</div>
            <div id="answers-container"></div>
        </div>
    </div>

<script>
    // --- å›¾ç‰‡èµ„æºç®¡ç† (ä¿æŒä¸å˜) ---
    const ASSETS_URLS = {
        grass: '/images/grass.jpg', 
        pathTexture: '/images/road.jpg',
        toybox: '/images/gamebox.png',
        monster: '/images/thief.png',
        teddy: '/images/teddy-bear.png', 
        duck: '/images/rubber-duck.png', 
        freezer: '/images/freezer-safe.png' 
    };

    const loadedImages = {};
    let assetsLoadedCount = 0;
    const totalAssets = Object.keys(ASSETS_URLS).length;

    function preloadAssets(callback) {
        for (let key in ASSETS_URLS) {
            const img = new Image();
            img.loadedSuccessfully = false; 
            img.onload = () => {
                img.loadedSuccessfully = true;
                assetsLoadedCount++;
                checkAllLoaded(callback);
            };
            img.onerror = () => {
                console.warn(`å›¾ç‰‡åŠ è½½å¤±è´¥: ${key} (${ASSETS_URLS[key]})ã€‚å°†ä½¿ç”¨æ›¿ä»£å›¾å½¢ã€‚`);
                img.loadedSuccessfully = false;
                assetsLoadedCount++;
                checkAllLoaded(callback);
            };
            img.crossOrigin = "Anonymous";
            img.src = ASSETS_URLS[key];
            loadedImages[key] = img;
        }
    }

    function checkAllLoaded(callback) {
        if (assetsLoadedCount === totalAssets) {
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
                callback(); 
            }, 500);
        }
    }


    // --- æ¸¸æˆé…ç½®ä¸å…¨å±€å˜é‡ ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const GAME_WIDTH = canvas.width;
    const GAME_HEIGHT = canvas.height;

    let gameState = 'PREP';
    let lives = 5;
    let wave = 1;
    let placingTowerTier = 0;

    // ç”¨äºè®°å½•å½“å‰æ³¢æ¬¡ä¸‰ç§éš¾åº¦çš„é¢˜ç›®æ˜¯å¦å·²å›ç­”æ­£ç¡®
    let waveQuestStatus = { 1: false, 2: false, 3: false };
    // ã€æ–°å¢ã€‘ç”¨äºè®°å½•å½“å‰æ³¢æ¬¡ä¸‰ç§éš¾åº¦çš„å¡”æ˜¯å¦å·²ç»æ”¾ç½®åœ¨åœ°å›¾ä¸Š
    let wavePlacementStatus = { 1: false, 2: false, 3: false };

    let towers = [];
    let enemies = [];
    let projectiles = [];

    const path = [
        {x: 0, y: 150}, {x: 650, y: 150},
        {x: 650, y: 450}, {x: 150, y: 450},
        {x: 150, y: 300}, {x: 800, y: 300}
    ];
    const PATH_WIDTH = 60;

    const TOWER_STATS = {
        1: { color: '#4CAF50', range: 120, damage: 30, cooldown: 60, name: "æ³°è¿ªç†Š", imgKey: 'teddy' },
        2: { color: '#2196F3', range: 150, damage: 50, cooldown: 50, name: "æ©¡çš®é¸­", imgKey: 'duck' },
        3: { color: '#F44336', range: 180, damage: 80, cooldown: 40, name: "å†·å†»æœº", imgKey: 'freezer' }
    };

    // --- æ ¸å¿ƒé€»è¾‘ç±» (Tower, Enemy, Projectile) ä¿æŒä¸å˜ ---
    class Tower {
        constructor(x, y, tier) {
            this.x = x; this.y = y; this.tier = tier;
            this.stats = TOWER_STATS[tier]; this.fireTimer = 0; this.radius = 25; 
            this.image = loadedImages[this.stats.imgKey];
        }
        update() {
            if (this.fireTimer > 0) this.fireTimer--;
            if (this.fireTimer === 0 && enemies.length > 0) {
                const target = this.findTarget();
                if (target) { this.fire(target); this.fireTimer = this.stats.cooldown; }
            }
        }
        findTarget() {
            let closestEnemy = null; let minDistance = this.stats.range;
            for (const enemy of enemies) {
                if (enemy.health <= 0) continue;
                const dx = enemy.x - this.x; const dy = enemy.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < minDistance) { closestEnemy = enemy; minDistance = distance; }
            }
            return closestEnemy;
        }
        fire(target) { projectiles.push(new Projectile(this.x, this.y, target, this.stats.damage, this.stats.color)); }
        draw() {
            if (this.image && this.image.loadedSuccessfully) {
                ctx.drawImage(this.image, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
            } else {
                ctx.fillStyle = this.stats.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.stroke();
            }
        }
    }

    class Enemy {
        constructor(health, speed, defense) {
            this.x = path[0].x; this.y = path[0].y; this.pathIndex = 0;
            this.health = health; this.maxHealth = health; this.speed = speed;
            this.defense = defense; 
            this.size = 60; 
            this.color = '#888'; 
            this.image = loadedImages['monster'];
        }
        update() {
            if (this.health <= 0) return true;
            if (this.pathIndex < path.length - 1) {
                let target = path[this.pathIndex + 1];
                let dx = target.x - this.x; let dy = target.y - this.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < this.speed) { this.pathIndex++; } else { this.x += (dx / distance) * this.speed; this.y += (dy / distance) * this.speed; }
            } else { lives--; updateUI(); return true; }
            return false;
        }
        draw() {
            if (this.image && this.image.loadedSuccessfully) {
                ctx.drawImage(this.image, this.x - this.size/2, this.y - this.size/2, this.size, this.size);
            } else {
                ctx.fillStyle = this.color; 
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
            }
            ctx.fillStyle = 'red'; ctx.fillRect(this.x - this.size/2, this.y - this.size/2 - 10, this.size, 5);
            ctx.fillStyle = '#0f0'; ctx.fillRect(this.x - this.size/2, this.y - this.size/2 - 10, this.size * (this.health / this.maxHealth), 5);
        }
    }

    class Projectile {
        constructor(x, y, target, damage, color) {
            this.x = x; this.y = y; this.target = target; this.damage = damage; this.color = color; this.speed = 10; this.markedForDeletion = false;
        }
        update() {
            if(this.target.health <=0) { this.markedForDeletion = true; return; }
            let dx = this.target.x - this.x; let dy = this.target.y - this.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < this.speed + this.target.size/2) { 
                let actualDamage = Math.max(1, this.damage - this.target.defense);
                this.target.health -= actualDamage; 
                this.markedForDeletion = true; 
            } else { 
                this.x += (dx / distance) * this.speed; this.y += (dy / distance) * this.speed; 
            }
        }
        draw() { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, 8, 0, Math.PI * 2); ctx.fill(); }
    }

    // --- æ¸¸æˆä¸»å¾ªç¯ (ä¿æŒä¸å˜) ---
    function gameLoop() {
        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        drawMap(); 
        if (lives <= 0) { drawGameOver(); return; }
        for (let i = enemies.length - 1; i >= 0; i--) { if (enemies[i].update()) { enemies.splice(i, 1); } }
        if (enemies.length === 0 && gameState === 'DEFEND') {
            gameState = 'PREP'; wave++; 
            // ã€ä¿®æ”¹ã€‘æ³¢æ¬¡ç»“æŸï¼Œé‡ç½®æ‰€æœ‰çŠ¶æ€
            resetWaveStates();
            updateUI();
            document.getElementById('btn-start').disabled = false; document.getElementById('btn-start').innerText = "â–¶ å¼€å§‹ä¸‹ä¸€æ³¢è¿›æ”»";
        }
        enemies.forEach(e => e.draw());
        towers.forEach(t => { t.update(); t.draw(); });
        for (let i = projectiles.length - 1; i >= 0; i--) {
            projectiles[i].update(); if (projectiles[i].markedForDeletion) projectiles.splice(i, 1);
        }
        projectiles.forEach(p => p.draw());
        if (placingTowerTier > 0) { drawPlacementPreview(); }
        requestAnimationFrame(gameLoop);
    }

    // --- è¾…åŠ©å‡½æ•° (ç»˜å›¾) (ä¿æŒä¸å˜) ---
    function drawMap() {
        const grassImg = loadedImages.grass;
        if (grassImg && grassImg.loadedSuccessfully) {
            const grassPattern = ctx.createPattern(grassImg, 'repeat');
            ctx.fillStyle = grassPattern;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        } else {
            ctx.fillStyle = '#a3d9a5'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        }
        ctx.lineWidth = PATH_WIDTH;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        const pathImg = loadedImages.pathTexture;
        if (pathImg && pathImg.loadedSuccessfully) {
            const pathPattern = ctx.createPattern(pathImg, 'repeat');
            ctx.strokeStyle = pathPattern;
        } else {
            ctx.strokeStyle = '#c4a484';
        }
        ctx.beginPath();
        ctx.moveTo(path[0].x, path[0].y);
        for (let i = 1; i < path.length; i++) {
            ctx.lineTo(path[i].x, path[i].y);
        }
        ctx.stroke();
        const endPt = path[path.length-1];
        const toyboxImg = loadedImages.toybox; 
        if (toyboxImg && toyboxImg.loadedSuccessfully) {
            const boxSize = 70; 
            ctx.drawImage(toyboxImg, endPt.x - boxSize/2, endPt.y - boxSize/2, boxSize, boxSize);
        } else {
            ctx.fillStyle = '#ff6b6b';
            ctx.fillRect(endPt.x - 30, endPt.y - 30, 60, 60);
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 4; ctx.strokeRect(endPt.x - 30, endPt.y - 30, 60, 60);
        }
    }
    
    function drawGameOver() {
        ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0,0,GAME_WIDTH, GAME_HEIGHT);
        ctx.fillStyle = 'white'; ctx.font = '50px Comic Sans MS'; ctx.textAlign = 'center';
        ctx.fillText("ç©å…·ä»¬ç´¯äº†ï¼Œä¸‹æ¬¡å†ç©å§ï¼", GAME_WIDTH/2, GAME_HEIGHT/2);
        ctx.font = '30px Comic Sans MS'; ctx.fillText("åˆ·æ–°é¡µé¢é‡æ–°å¼€å§‹", GAME_WIDTH/2, GAME_HEIGHT/2 + 50);
    }

    function drawPlacementPreview() {
        const stats = TOWER_STATS[placingTowerTier];
        const img = loadedImages[stats.imgKey];
        const radius = 25;
        ctx.font = "20px Arial"; ctx.fillStyle = stats.color; ctx.fillText(`ç‚¹å‡»è‰åœ°æ”¾ç½®${stats.name}`, mouseX + 25, mouseY);
        ctx.globalAlpha = 0.6;
        if (img && img.loadedSuccessfully) {
             ctx.drawImage(img, mouseX - radius, mouseY - radius, radius * 2, radius * 2);
        } else {
             ctx.fillStyle = stats.color; ctx.beginPath(); ctx.arc(mouseX, mouseY, radius, 0, Math.PI * 2); ctx.fill();
        }
        ctx.globalAlpha = 1.0;
        ctx.beginPath(); ctx.arc(mouseX, mouseY, stats.range, 0, Math.PI*2);
        ctx.strokeStyle = stats.color; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
    }

    // ã€ä¿®æ”¹ã€‘æ›´æ–°UIï¼Œæ˜¾ç¤ºç­”é¢˜å’Œæ”¾ç½®ä¸¤ç§çŠ¶æ€
    function updateUI() {
        let heartsStr = ""; for(let i=0; i<lives; i++) heartsStr += "â¤ï¸"; if(lives === 0) heartsStr = "ğŸ’”";
        document.getElementById('lives-display').innerText = heartsStr; document.getElementById('wave-display').innerText = wave;

        updateStatusUI('q1-quest', waveQuestStatus[1], 'status-done', 'status-todo');
        updateStatusUI('q2-quest', waveQuestStatus[2], 'status-done', 'status-todo');
        updateStatusUI('q3-quest', waveQuestStatus[3], 'status-done', 'status-todo');

        updateStatusUI('q1-placed', wavePlacementStatus[1], 'status-placed', 'status-todo');
        updateStatusUI('q2-placed', wavePlacementStatus[2], 'status-placed', 'status-todo');
        updateStatusUI('q3-placed', wavePlacementStatus[3], 'status-placed', 'status-todo');
    }

    // ã€æ–°å¢ã€‘é€šç”¨çŠ¶æ€å›¾æ ‡æ›´æ–°å‡½æ•°
    function updateStatusUI(elementId, isDone, doneClass, todoClass) {
        const el = document.getElementById(elementId);
        if (isDone) {
            el.innerText = 'âœ“';
            el.className = doneClass;
        } else {
            el.innerText = 'âœ—';
            el.className = todoClass;
        }
    }

    // è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥æ˜¯å¦å®Œæˆäº†å½“å‰æ³¢æ¬¡çš„æ‰€æœ‰ç­”é¢˜ä»»åŠ¡
    function areAllQuestsCompleted() {
        return waveQuestStatus[1] && waveQuestStatus[2] && waveQuestStatus[3];
    }

    // ã€ä¿®æ”¹ã€‘è¾…åŠ©å‡½æ•°ï¼šé‡ç½®æ³¢æ¬¡æ‰€æœ‰çŠ¶æ€ï¼ˆç­”é¢˜å’Œæ”¾ç½®ï¼‰
    function resetWaveStates() {
        waveQuestStatus = { 1: false, 2: false, 3: false };
        wavePlacementStatus = { 1: false, 2: false, 3: false };
    }

    // --- äº¤äº’äº‹ä»¶å¤„ç† ---
    let mouseX = 0; let mouseY = 0;
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect(); mouseX = e.clientX - rect.left; mouseY = e.clientY - rect.top;
    });
    
    // ã€ä¿®æ”¹ã€‘ç‚¹å‡»ç”»å¸ƒæ”¾ç½®å¡”çš„é€»è¾‘
    canvas.addEventListener('click', (e) => {
        if (placingTowerTier === 0) return;

        const rect = canvas.getBoundingClientRect(); const clickX = e.clientX - rect.left; const clickY = e.clientY - rect.top;
        let onPath = false; if (ctx.isPointInStroke(clickX, clickY)) onPath = true;
        let overlaps = towers.some(t => Math.hypot(t.x - clickX, t.y - clickY) < 50);
        if (!onPath && !overlaps) {
            towers.push(new Tower(clickX, clickY, placingTowerTier));
            // ã€æ–°å¢ã€‘æ”¾ç½®æˆåŠŸåï¼Œæ ‡è®°è¯¥ç±»å‹å·²æ”¾ç½®
            wavePlacementStatus[placingTowerTier] = true;
            updateUI(); // æ›´æ–°UIæ˜¾ç¤ºæ”¾ç½®çŠ¶æ€
            placingTowerTier = 0; 
            canvas.style.cursor = 'crosshair';
        } else { console.log("ä¸èƒ½æ”¾åœ¨è¿™é‡Œï¼"); }
    });

    // ==========================================
    // å¼€å§‹ä¸‹ä¸€æ³¢è¿›æ”»çš„é€»è¾‘ (åŒ…å«éš¾åº¦å‡çº§)
    // ==========================================
    function startNextWave() {
        // æ ¸å¿ƒæ£€æŸ¥ï¼šå¦‚æœå½“å‰æ˜¯å‡†å¤‡é˜¶æ®µï¼Œä¸”ä»»åŠ¡æœªå…¨éƒ¨å®Œæˆï¼Œé˜»æ­¢å¼€å§‹ä¸‹ä¸€æ³¢
        if (gameState === 'PREP' && !areAllQuestsCompleted()) {
            alert("æ— æ³•å¼€å§‹ï¼è¯·å…ˆå®Œæˆæœ¬æ³¢æ¬¡çš„ä¸‰é¡¹ç­”é¢˜ä»»åŠ¡ï¼ˆç®€å•ã€ä¸­ç­‰ã€å›°éš¾å„ä¸€é¢˜ï¼‰ã€‚");
            return;
        }

        if (gameState === 'DEFEND') return;
        gameState = 'DEFEND'; 
        document.getElementById('btn-start').disabled = true; 
        document.getElementById('btn-start').innerText = "è¿›æ”»ä¸­...";

        // --- éš¾åº¦è®¡ç®—é€»è¾‘ (å·²ç¡®è®¤åŒ…å«ï¼š25%æ•°å€¼å¢é•¿ + 15%é˜²å¾¡å¢é•¿) ---
        // 1. å®šä¹‰ç¬¬1æ³¢çš„åŸºç¡€æ•°å€¼
        const baseEnemyCount = 5;      
        const baseEnemySpeed = 1.0;    
        const baseEnemyHealth = 70;    
        const baseEnemyDefense = 0; 

        // 2. å®šä¹‰å¢é•¿å› å­
        const generalGrowthFactor = 1.35; // ã€ç¡®è®¤ã€‘æ•°é‡ã€é€Ÿåº¦ã€è¡€é‡å¢é•¿ 25%
        const defenseGrowthFactor = 1.35; // ã€ç¡®è®¤ã€‘é˜²å¾¡åŠ›å¢é•¿ 25%

        // 3. ä½¿ç”¨æŒ‡æ•°å…¬å¼è®¡ç®—å½“å‰æ³¢æ¬¡çš„å€¼
        let currentEnemyCount = Math.round(baseEnemyCount * Math.pow(generalGrowthFactor, wave - 1));
        let currentEnemySpeed = baseEnemySpeed * Math.pow(generalGrowthFactor, wave - 1);
        let currentEnemyHealth = Math.round(baseEnemyHealth * Math.pow(generalGrowthFactor, wave - 1));
        // è®¡ç®—é˜²å¾¡åŠ› (å–æ•´)
        let currentEnemyDefense = wave === 1 ? 0 : Math.round(5 * Math.pow(defenseGrowthFactor, wave - 1));

        console.log(`ç¬¬ ${wave} æ³¢: æ•°é‡=${currentEnemyCount}, é€Ÿåº¦=${currentEnemySpeed.toFixed(2)}, è¡€é‡=${currentEnemyHealth}, é˜²å¾¡=${currentEnemyDefense}`);

        // 4. ç”Ÿæˆæ•Œäºº
        for (let i = 0; i < currentEnemyCount; i++) {
            setTimeout(() => { 
                // ä¼ é€’é˜²å¾¡åŠ›å‚æ•°
                enemies.push(new Enemy(currentEnemyHealth, currentEnemySpeed, currentEnemyDefense)); 
            }, i * 1500); 
        }
    }

    // --- æ•°å­¦é¢˜ç›®æ¨¡å— ---
    const modal = document.getElementById('math-modal');
    const questionText = document.getElementById('question-text');
    const questionVisual = document.getElementById('question-visual');
    const answersContainer = document.getElementById('answers-container');
    let currentCorrectAnswer = 0; let currentRewardTier = 0;

    // ã€ä¿®æ”¹ã€‘ç‚¹å‡»ç­”é¢˜æŒ‰é’®çš„é€»è¾‘
    function askQuestion(tier) {
        if (placingTowerTier !== 0) { alert("è¯·å…ˆå®Œæˆå½“å‰æ”¾ç½®æ“ä½œï¼Œç‚¹å‡»è‰åœ°æ”¾ç½®å¡”ã€‚"); return; }
        
        // ã€æ–°å¢ã€‘æ£€æŸ¥1ï¼šæœ¬æ³¢æ˜¯å¦å·²ç»æ”¾ç½®è¿‡è¯¥ç±»å‹çš„å¡”ï¼Ÿ
        if (wavePlacementStatus[tier]) {
            alert("æœ¬æ³¢æ¬¡å·²æ”¾ç½®è¿‡è¯¥ç±»å‹çš„ç©å…·ï¼Œè¯·é€‰æ‹©å…¶ä»–ç±»å‹ï¼");
            return;
        }

        // ã€æ–°å¢ã€‘æ£€æŸ¥2ï¼šè™½ç„¶æ²¡æ”¾ï¼Œä½†æ˜¯ä¸æ˜¯å·²ç»ç­”å¯¹è¿‡äº†ï¼Ÿ
        if (waveQuestStatus[tier]) {
            // å¦‚æœç­”å¯¹äº†ä½†æ²¡æ”¾ï¼Œç›´æ¥è¿›å…¥æ”¾ç½®æ¨¡å¼ï¼Œä¸ç”¨å†ç­”é¢˜
            alert("æ‚¨å·²ç­”å¯¹è¯¥éš¾åº¦çš„é¢˜ç›®ï¼Œè¯·ç›´æ¥åœ¨åœ°å›¾ä¸Šæ”¾ç½®ç©å…·ã€‚");
            currentRewardTier = tier;
            placingTowerTier = currentRewardTier; 
            canvas.style.cursor = 'grabbing';
            return;
        }

        // å¦‚æœæ—¢æ²¡æ”¾ä¹Ÿæ²¡ç­”å¯¹ï¼Œåˆ™å¼¹å‡ºé¢˜ç›®
        currentRewardTier = tier; modal.style.display = 'flex'; generateQuestion(tier);
    }

    function generateQuestion(tier) {
        // (ä¿æŒä¸å˜) ...
        answersContainer.innerHTML = ''; questionVisual.innerHTML = ''; let qText = ''; let answer = 0; let visualEmoji = '';
        switch(tier) {
            case 1: 
                answer = Math.floor(Math.random() * 5) + 1; visualEmoji = ['ğŸ','ğŸŒ','ğŸ±','ğŸ¶','ğŸš—'][Math.floor(Math.random()*5)];
                for(let i=0; i<answer; i++) questionVisual.innerHTML += visualEmoji + ' ';
                qText = `æ•°ä¸€æ•°ï¼Œè¿™é‡Œæœ‰å‡ ä¸ª ${visualEmoji}ï¼Ÿ`; break;
            case 2: 
                let a2 = Math.floor(Math.random() * 5) + 1; let b2 = Math.floor(Math.random() * 4) + 1; answer = a2 + b2;
                qText = `${a2} + ${b2} = ?`; questionVisual.innerHTML = `${'ğŸ”µ'.repeat(a2)} â• ${'ğŸ”µ'.repeat(b2)}`; break;
            case 3: 
                if (Math.random() > 0.5) {
                    let a3 = Math.floor(Math.random() * 5) + 5; let b3 = Math.floor(Math.random() * a3); answer = a3 - b3;
                    qText = `${a3} - ${b3} = ?`; questionVisual.innerHTML = `${'ğŸ”´'.repeat(a3)} â– ${'ğŸ”´'.repeat(b3)}`;
                } else {
                    let n1 = Math.floor(Math.random() * 10) + 1; let n2 = n1; while(n2 === n1) n2 = Math.floor(Math.random() * 10) + 1;
                    answer = Math.max(n1, n2); qText = `å“ªä¸€ä¸ªæ•°å­—æ›´å¤§ï¼Ÿ ${n1} è¿˜æ˜¯ ${n2}ï¼Ÿ`;
                } break;
        }
        questionText.innerText = qText; currentCorrectAnswer = answer; generateAnswerButtons(answer, tier);
    }
    function generateAnswerButtons(correctAnswer, tier) {
        // (ä¿æŒä¸å˜) ...
        let answers = [correctAnswer];
        while (answers.length < 3) {
            let wrong;
            if (tier === 3 && answers[0] > 5) { wrong = Math.floor(Math.random() * 10) + 1; } else { wrong = Math.floor(Math.random() * (correctAnswer + 3)) + 1; }
            if (!answers.includes(wrong) && wrong > 0) answers.push(wrong);
        }
        answers.sort(() => Math.random() - 0.5);
        answers.forEach(ans => {
            const btn = document.createElement('button'); btn.className = 'answer-btn'; btn.innerText = ans;
            btn.onclick = () => checkAnswer(ans); answersContainer.appendChild(btn);
        });
    }
    
    // å›ç­”æ­£ç¡®åçš„å¤„ç†é€»è¾‘
    function checkAnswer(selectedAnswer) {
        if (selectedAnswer === currentCorrectAnswer) {
            modal.style.display = 'none'; 
            // æ ‡è®°å½“å‰éš¾åº¦çš„ä»»åŠ¡ä¸ºå·²å®Œæˆ
            waveQuestStatus[currentRewardTier] = true;
            updateUI(); // æ›´æ–°UIæ˜¾ç¤ºç­”é¢˜å¯¹å‹¾

            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ä»»åŠ¡éƒ½å®Œæˆäº†ï¼Œå¦‚æœæ˜¯ï¼Œæç¤ºå¯ä»¥å¼€å§‹ä¸‹ä¸€æ³¢äº†
            if (areAllQuestsCompleted()) {
                alert("æ­å–œï¼æœ¬æ³¢æ¬¡æ‰€æœ‰ç­”é¢˜ä»»åŠ¡å·²å®Œæˆï¼è¯·æ”¾ç½®å¥½ç©å…·åç‚¹å‡»â€œå¼€å§‹ä¸‹ä¸€æ³¢è¿›æ”»â€ã€‚");
            }

            placingTowerTier = currentRewardTier; 
            canvas.style.cursor = 'grabbing';
        } else {
            questionText.innerText = "å“å‘€ï¼Œä¸å¯¹å“¦ï¼Œå†æƒ³æƒ³ï¼";
            document.getElementById('modal-content').style.transform = 'translateX(10px)';
            setTimeout(() => { document.getElementById('modal-content').style.transform = 'translateX(0px)'; }, 100);
        }
    }

    // --- åˆå§‹åŒ–æ¸¸æˆ ---
    preloadAssets(() => { 
        // æ¸¸æˆå¼€å§‹æ—¶å…ˆé‡ç½®ä¸€ä¸‹çŠ¶æ€
        resetWaveStates();
        updateUI(); 
        gameLoop(); 
    });

</script>
</body>
</html>